-----------------------------------------------------------------------------
Info file generated by Happy Version 1.20.1.1 from src/Futz/Parser.y
-----------------------------------------------------------------------------

state 16 contains 4 reduce/reduce conflicts.
state 23 contains 3 shift/reduce conflicts.
state 27 contains 6 reduce/reduce conflicts.
state 31 contains 6 reduce/reduce conflicts.
state 41 contains 1 shift/reduce conflicts.
state 60 contains 1 shift/reduce conflicts.

rule 11 is unused
rule 15 is unused
rule 23 is unused
rule 24 is unused
rule 25 is unused
rule 28 is unused
rule 29 is unused
rule 33 is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parseFutz -> toplevel                       (0)
	toplevel -> statement                              (1)
	toplevel -> statement toplevel                     (2)
	statement -> sol var "::" qualtype                 (3)
	statement -> sol '(' op ')' "::" qualtype          (4)
	statement -> sol var '=' exp                       (5)
	statement -> sol '(' op ')' '=' exp                (6)
	statement -> sol data tname listof__tvar__ '=' ctors   (7)
	exp -> let var '=' exp in exp                      (8)
	exp -> if exp then exp else exp                    (9)
	exp -> 'λ' unmatching_args arr exp                 (10)
	exp -> var                                         (11)
	exp -> expapp                                      (12)
	exp -> atom of exp                                 (13)
	exp -> atom op exp                                 (14)
	exp -> atom                                        (15)
	exp -> op                                          (16)
	expapp -> expapp atom                              (17)
	expapp -> atom                                     (18)
	atom -> int                                        (19)
	atom -> var                                        (20)
	atom -> '(' op ')'                                 (21)
	atom -> '(' exp ')'                                (22)
	argument -> var                                    (23)
	args -> argument                                   (24)
	args -> argument args                              (25)
	unmatching_args -> var                             (26)
	unmatching_args -> var unmatching_args             (27)
	typeParameters -> simpleType                       (28)
	typeParameters -> simpleType typeParameters        (29)
	simpleType -> tname                                (30)
	simpleType -> tvar                                 (31)
	simpleType -> '(' type ')'                         (32)
	type -> simpleType                                 (33)
	type -> tApp                                       (34)
	type -> type arr type                              (35)
	tApp -> simpleType                                 (36)
	tApp -> tApp simpleType                            (37)
	ctor -> tname listof__simpleType__                 (38)
	ctor -> tname                                      (39)
	ctors -> ctor                                      (40)
	ctors -> ctor pipe ctors                           (41)
	qualtype -> preds '=>' type                        (42)
	qualtype -> type                                   (43)
	preds -> pred                                      (44)
	preds -> pred pipe preds                           (45)
	pred -> tname simpleType                           (46)
	listof__simpleType__ -> simpleType                 (47)
	listof__simpleType__ -> simpleType listof__simpleType__   (48)
	listof__tvar__ -> tvar                             (49)
	listof__tvar__ -> tvar listof__tvar__              (50)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	let            { Tok _ LSyntax "let" }
	in             { Tok _ LSyntax "in" }
	of             { Tok _ LSyntax "of" }
	if             { Tok _ LSyntax "if" }
	then           { Tok _ LSyntax "then" }
	else           { Tok _ LSyntax "else" }
	data           { Tok _ LSyntax "data" }
	pipe           { Tok _ LPipe _ }
	'=>'           { Tok _ LOp "=>" }
	int            { Tok _ LInt _ }
	var            { Tok _ LSym _ }
	op             { Tok _ LOp _ }
	'='            { Tok _ LEq  _ }
	'('            { Tok _ LLParen _ }
	')'            { Tok _ LRParen _ }
	arr            { Tok _ LArrow _ }
	'λ'            { Tok _ LLambda _ }
	tname          { Tok _ LType $$ }
	tvar           { Tok _ LTypeVar $$ }
	"::"           { Tok _ LIsType _ }
	sol            { TStartOfLine }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parseFutz rule  0
	toplevel        rules 1, 2
	statement       rules 3, 4, 5, 6, 7
	exp             rules 8, 9, 10, 11, 12, 13, 14, 15, 16
	expapp          rules 17, 18
	atom            rules 19, 20, 21, 22
	argument        rule  23
	args            rules 24, 25
	unmatching_args rules 26, 27
	typeParameters  rules 28, 29
	simpleType      rules 30, 31, 32
	type            rules 33, 34, 35
	tApp            rules 36, 37
	ctor            rules 38, 39
	ctors           rules 40, 41
	qualtype        rules 42, 43
	preds           rules 44, 45
	pred            rule  46
	listof__simpleType__ rules 47, 48
	listof__tvar__  rules 49, 50

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0

	%start_parseFutz -> . toplevel                      (rule 0)

	sol            shift, and enter state 3

	toplevel       goto state 4
	statement      goto state 5

State 1

	toplevel -> . statement                             (rule 1)

	sol            shift, and enter state 3

	statement      goto state 2

State 2

	toplevel -> statement .                             (rule 1)



State 3

	statement -> sol . var "::" qualtype                (rule 3)
	statement -> sol . '(' op ')' "::" qualtype         (rule 4)
	statement -> sol . var '=' exp                      (rule 5)
	statement -> sol . '(' op ')' '=' exp               (rule 6)
	statement -> sol . data tname listof__tvar__ '=' ctors    (rule 7)

	data           shift, and enter state 7
	var            shift, and enter state 8
	'('            shift, and enter state 9


State 4

	%start_parseFutz -> toplevel .                      (rule 0)

	%eof           accept


State 5

	toplevel -> statement .                             (rule 1)
	toplevel -> statement . toplevel                    (rule 2)

	sol            shift, and enter state 3
	%eof           reduce using rule 1

	toplevel       goto state 6
	statement      goto state 5

State 6

	toplevel -> statement toplevel .                    (rule 2)

	%eof           reduce using rule 2


State 7

	statement -> sol data . tname listof__tvar__ '=' ctors    (rule 7)

	tname          shift, and enter state 13


State 8

	statement -> sol var . "::" qualtype                (rule 3)
	statement -> sol var . '=' exp                      (rule 5)

	'='            shift, and enter state 11
	"::"           shift, and enter state 12


State 9

	statement -> sol '(' . op ')' "::" qualtype         (rule 4)
	statement -> sol '(' . op ')' '=' exp               (rule 6)

	op             shift, and enter state 10


State 10

	statement -> sol '(' op . ')' "::" qualtype         (rule 4)
	statement -> sol '(' op . ')' '=' exp               (rule 6)

	')'            shift, and enter state 35


State 11

	statement -> sol var '=' . exp                      (rule 5)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 25
	expapp         goto state 26
	atom           goto state 27

State 12

	statement -> sol var "::" . qualtype                (rule 3)

	'('            shift, and enter state 22
	tname          shift, and enter state 23
	tvar           shift, and enter state 24

	simpleType     goto state 16
	type           goto state 17
	tApp           goto state 18
	qualtype       goto state 19
	preds          goto state 20
	pred           goto state 21

State 13

	statement -> sol data tname . listof__tvar__ '=' ctors    (rule 7)

	tvar           shift, and enter state 15

	listof__tvar__ goto state 14

State 14

	statement -> sol data tname listof__tvar__ . '=' ctors    (rule 7)

	'='            shift, and enter state 56


State 15

	listof__tvar__ -> tvar .                            (rule 49)
	listof__tvar__ -> tvar . listof__tvar__             (rule 50)

	'='            reduce using rule 49
	tvar           shift, and enter state 15

	listof__tvar__ goto state 55

State 16

	type -> simpleType .                                (rule 33)
	tApp -> simpleType .                                (rule 36)

	'('            reduce using rule 36
	')'            reduce using rule 36
			(reduce using rule 33)

	arr            reduce using rule 36
			(reduce using rule 33)

	tname          reduce using rule 36
	tvar           reduce using rule 36
	sol            reduce using rule 36
			(reduce using rule 33)

	%eof           reduce using rule 36
			(reduce using rule 33)



State 17

	type -> type . arr type                             (rule 35)
	qualtype -> type .                                  (rule 43)

	arr            shift, and enter state 54
	sol            reduce using rule 43
	%eof           reduce using rule 43


State 18

	type -> tApp .                                      (rule 34)
	tApp -> tApp . simpleType                           (rule 37)

	'('            shift, and enter state 22
	')'            reduce using rule 34
	arr            reduce using rule 34
	tname          shift, and enter state 49
	tvar           shift, and enter state 24
	sol            reduce using rule 34
	%eof           reduce using rule 34

	simpleType     goto state 53

State 19

	statement -> sol var "::" qualtype .                (rule 3)

	sol            reduce using rule 3
	%eof           reduce using rule 3


State 20

	qualtype -> preds . '=>' type                       (rule 42)

	'=>'           shift, and enter state 52


State 21

	preds -> pred .                                     (rule 44)
	preds -> pred . pipe preds                          (rule 45)

	pipe           shift, and enter state 51
	'=>'           reduce using rule 44


State 22

	simpleType -> '(' . type ')'                        (rule 32)

	'('            shift, and enter state 22
	tname          shift, and enter state 49
	tvar           shift, and enter state 24

	simpleType     goto state 16
	type           goto state 50
	tApp           goto state 18

State 23

	simpleType -> tname .                               (rule 30)
	pred -> tname . simpleType                          (rule 46)

	'('            shift, and enter state 22
			(reduce using rule 30)

	arr            reduce using rule 30
	tname          shift, and enter state 49
			(reduce using rule 30)

	tvar           shift, and enter state 24
			(reduce using rule 30)

	sol            reduce using rule 30
	%eof           reduce using rule 30

	simpleType     goto state 48

State 24

	simpleType -> tvar .                                (rule 31)

	pipe           reduce using rule 31
	'=>'           reduce using rule 31
	'('            reduce using rule 31
	')'            reduce using rule 31
	arr            reduce using rule 31
	tname          reduce using rule 31
	tvar           reduce using rule 31
	sol            reduce using rule 31
	%eof           reduce using rule 31


State 25

	statement -> sol var '=' exp .                      (rule 5)

	sol            reduce using rule 5
	%eof           reduce using rule 5


State 26

	exp -> expapp .                                     (rule 12)
	expapp -> expapp . atom                             (rule 17)

	in             reduce using rule 12
	then           reduce using rule 12
	else           reduce using rule 12
	int            shift, and enter state 30
	var            shift, and enter state 47
	'('            shift, and enter state 33
	')'            reduce using rule 12
	sol            reduce using rule 12
	%eof           reduce using rule 12

	atom           goto state 46

State 27

	exp -> atom . of exp                                (rule 13)
	exp -> atom . op exp                                (rule 14)
	exp -> atom .                                       (rule 15)
	expapp -> atom .                                    (rule 18)

	in             reduce using rule 18
			(reduce using rule 15)

	of             shift, and enter state 44
	then           reduce using rule 18
			(reduce using rule 15)

	else           reduce using rule 18
			(reduce using rule 15)

	int            reduce using rule 18
	var            reduce using rule 18
	op             shift, and enter state 45
	'('            reduce using rule 18
	')'            reduce using rule 18
			(reduce using rule 15)

	sol            reduce using rule 18
			(reduce using rule 15)

	%eof           reduce using rule 18
			(reduce using rule 15)



State 28

	exp -> let . var '=' exp in exp                     (rule 8)

	var            shift, and enter state 43


State 29

	exp -> if . exp then exp else exp                   (rule 9)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 42
	expapp         goto state 26
	atom           goto state 27

State 30

	atom -> int .                                       (rule 19)

	in             reduce using rule 19
	of             reduce using rule 19
	then           reduce using rule 19
	else           reduce using rule 19
	int            reduce using rule 19
	var            reduce using rule 19
	op             reduce using rule 19
	'('            reduce using rule 19
	')'            reduce using rule 19
	sol            reduce using rule 19
	%eof           reduce using rule 19


State 31

	exp -> var .                                        (rule 11)
	atom -> var .                                       (rule 20)

	in             reduce using rule 20
			(reduce using rule 11)

	of             reduce using rule 20
	then           reduce using rule 20
			(reduce using rule 11)

	else           reduce using rule 20
			(reduce using rule 11)

	int            reduce using rule 20
	var            reduce using rule 20
	op             reduce using rule 20
	'('            reduce using rule 20
	')'            reduce using rule 20
			(reduce using rule 11)

	sol            reduce using rule 20
			(reduce using rule 11)

	%eof           reduce using rule 20
			(reduce using rule 11)



State 32

	exp -> op .                                         (rule 16)

	in             reduce using rule 16
	then           reduce using rule 16
	else           reduce using rule 16
	')'            reduce using rule 16
	sol            reduce using rule 16
	%eof           reduce using rule 16


State 33

	atom -> '(' . op ')'                                (rule 21)
	atom -> '(' . exp ')'                               (rule 22)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 41
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 40
	expapp         goto state 26
	atom           goto state 27

State 34

	exp -> 'λ' . unmatching_args arr exp                (rule 10)

	var            shift, and enter state 39

	unmatching_argsgoto state 38

State 35

	statement -> sol '(' op ')' . "::" qualtype         (rule 4)
	statement -> sol '(' op ')' . '=' exp               (rule 6)

	'='            shift, and enter state 36
	"::"           shift, and enter state 37


State 36

	statement -> sol '(' op ')' '=' . exp               (rule 6)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 74
	expapp         goto state 26
	atom           goto state 27

State 37

	statement -> sol '(' op ')' "::" . qualtype         (rule 4)

	'('            shift, and enter state 22
	tname          shift, and enter state 23
	tvar           shift, and enter state 24

	simpleType     goto state 16
	type           goto state 17
	tApp           goto state 18
	qualtype       goto state 73
	preds          goto state 20
	pred           goto state 21

State 38

	exp -> 'λ' unmatching_args . arr exp                (rule 10)

	arr            shift, and enter state 72


State 39

	unmatching_args -> var .                            (rule 26)
	unmatching_args -> var . unmatching_args            (rule 27)

	var            shift, and enter state 39
	arr            reduce using rule 26

	unmatching_argsgoto state 71

State 40

	atom -> '(' exp . ')'                               (rule 22)

	')'            shift, and enter state 70


State 41

	exp -> op .                                         (rule 16)
	atom -> '(' op . ')'                                (rule 21)

	')'            shift, and enter state 69
			(reduce using rule 16)



State 42

	exp -> if exp . then exp else exp                   (rule 9)

	then           shift, and enter state 68


State 43

	exp -> let var . '=' exp in exp                     (rule 8)

	'='            shift, and enter state 67


State 44

	exp -> atom of . exp                                (rule 13)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 66
	expapp         goto state 26
	atom           goto state 27

State 45

	exp -> atom op . exp                                (rule 14)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 65
	expapp         goto state 26
	atom           goto state 27

State 46

	expapp -> expapp atom .                             (rule 17)

	in             reduce using rule 17
	then           reduce using rule 17
	else           reduce using rule 17
	int            reduce using rule 17
	var            reduce using rule 17
	'('            reduce using rule 17
	')'            reduce using rule 17
	sol            reduce using rule 17
	%eof           reduce using rule 17


State 47

	atom -> var .                                       (rule 20)

	in             reduce using rule 20
	then           reduce using rule 20
	else           reduce using rule 20
	int            reduce using rule 20
	var            reduce using rule 20
	'('            reduce using rule 20
	')'            reduce using rule 20
	sol            reduce using rule 20
	%eof           reduce using rule 20


State 48

	pred -> tname simpleType .                          (rule 46)

	pipe           reduce using rule 46
	'=>'           reduce using rule 46


State 49

	simpleType -> tname .                               (rule 30)

	pipe           reduce using rule 30
	'=>'           reduce using rule 30
	'('            reduce using rule 30
	')'            reduce using rule 30
	arr            reduce using rule 30
	tname          reduce using rule 30
	tvar           reduce using rule 30
	sol            reduce using rule 30
	%eof           reduce using rule 30


State 50

	simpleType -> '(' type . ')'                        (rule 32)
	type -> type . arr type                             (rule 35)

	')'            shift, and enter state 64
	arr            shift, and enter state 54


State 51

	preds -> pred pipe . preds                          (rule 45)

	tname          shift, and enter state 63

	preds          goto state 62
	pred           goto state 21

State 52

	qualtype -> preds '=>' . type                       (rule 42)

	'('            shift, and enter state 22
	tname          shift, and enter state 49
	tvar           shift, and enter state 24

	simpleType     goto state 16
	type           goto state 61
	tApp           goto state 18

State 53

	tApp -> tApp simpleType .                           (rule 37)

	'('            reduce using rule 37
	')'            reduce using rule 37
	arr            reduce using rule 37
	tname          reduce using rule 37
	tvar           reduce using rule 37
	sol            reduce using rule 37
	%eof           reduce using rule 37


State 54

	type -> type arr . type                             (rule 35)

	'('            shift, and enter state 22
	tname          shift, and enter state 49
	tvar           shift, and enter state 24

	simpleType     goto state 16
	type           goto state 60
	tApp           goto state 18

State 55

	listof__tvar__ -> tvar listof__tvar__ .             (rule 50)

	'='            reduce using rule 50


State 56

	statement -> sol data tname listof__tvar__ '=' . ctors    (rule 7)

	tname          shift, and enter state 59

	ctor           goto state 57
	ctors          goto state 58

State 57

	ctors -> ctor .                                     (rule 40)
	ctors -> ctor . pipe ctors                          (rule 41)

	pipe           shift, and enter state 80
	sol            reduce using rule 40
	%eof           reduce using rule 40


State 58

	statement -> sol data tname listof__tvar__ '=' ctors .    (rule 7)

	sol            reduce using rule 7
	%eof           reduce using rule 7


State 59

	ctor -> tname . listof__simpleType__                (rule 38)
	ctor -> tname .                                     (rule 39)

	pipe           reduce using rule 39
	'('            shift, and enter state 22
	tname          shift, and enter state 49
	tvar           shift, and enter state 24
	sol            reduce using rule 39
	%eof           reduce using rule 39

	simpleType     goto state 78
	listof__simpleType__goto state 79

State 60

	type -> type . arr type                             (rule 35)
	type -> type arr type .                             (rule 35)

	')'            reduce using rule 35
	arr            shift, and enter state 54
			(reduce using rule 35)

	sol            reduce using rule 35
	%eof           reduce using rule 35


State 61

	type -> type . arr type                             (rule 35)
	qualtype -> preds '=>' type .                       (rule 42)

	arr            shift, and enter state 54
	sol            reduce using rule 42
	%eof           reduce using rule 42


State 62

	preds -> pred pipe preds .                          (rule 45)

	'=>'           reduce using rule 45


State 63

	pred -> tname . simpleType                          (rule 46)

	'('            shift, and enter state 22
	tname          shift, and enter state 49
	tvar           shift, and enter state 24

	simpleType     goto state 48

State 64

	simpleType -> '(' type ')' .                        (rule 32)

	pipe           reduce using rule 32
	'=>'           reduce using rule 32
	'('            reduce using rule 32
	')'            reduce using rule 32
	arr            reduce using rule 32
	tname          reduce using rule 32
	tvar           reduce using rule 32
	sol            reduce using rule 32
	%eof           reduce using rule 32


State 65

	exp -> atom op exp .                                (rule 14)

	in             reduce using rule 14
	then           reduce using rule 14
	else           reduce using rule 14
	')'            reduce using rule 14
	sol            reduce using rule 14
	%eof           reduce using rule 14


State 66

	exp -> atom of exp .                                (rule 13)

	in             reduce using rule 13
	then           reduce using rule 13
	else           reduce using rule 13
	')'            reduce using rule 13
	sol            reduce using rule 13
	%eof           reduce using rule 13


State 67

	exp -> let var '=' . exp in exp                     (rule 8)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 77
	expapp         goto state 26
	atom           goto state 27

State 68

	exp -> if exp then . exp else exp                   (rule 9)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 76
	expapp         goto state 26
	atom           goto state 27

State 69

	atom -> '(' op ')' .                                (rule 21)

	in             reduce using rule 21
	of             reduce using rule 21
	then           reduce using rule 21
	else           reduce using rule 21
	int            reduce using rule 21
	var            reduce using rule 21
	op             reduce using rule 21
	'('            reduce using rule 21
	')'            reduce using rule 21
	sol            reduce using rule 21
	%eof           reduce using rule 21


State 70

	atom -> '(' exp ')' .                               (rule 22)

	in             reduce using rule 22
	of             reduce using rule 22
	then           reduce using rule 22
	else           reduce using rule 22
	int            reduce using rule 22
	var            reduce using rule 22
	op             reduce using rule 22
	'('            reduce using rule 22
	')'            reduce using rule 22
	sol            reduce using rule 22
	%eof           reduce using rule 22


State 71

	unmatching_args -> var unmatching_args .            (rule 27)

	arr            reduce using rule 27


State 72

	exp -> 'λ' unmatching_args arr . exp                (rule 10)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 75
	expapp         goto state 26
	atom           goto state 27

State 73

	statement -> sol '(' op ')' "::" qualtype .         (rule 4)

	sol            reduce using rule 4
	%eof           reduce using rule 4


State 74

	statement -> sol '(' op ')' '=' exp .               (rule 6)

	sol            reduce using rule 6
	%eof           reduce using rule 6


State 75

	exp -> 'λ' unmatching_args arr exp .                (rule 10)

	in             reduce using rule 10
	then           reduce using rule 10
	else           reduce using rule 10
	')'            reduce using rule 10
	sol            reduce using rule 10
	%eof           reduce using rule 10


State 76

	exp -> if exp then exp . else exp                   (rule 9)

	else           shift, and enter state 84


State 77

	exp -> let var '=' exp . in exp                     (rule 8)

	in             shift, and enter state 83


State 78

	listof__simpleType__ -> simpleType .                (rule 47)
	listof__simpleType__ -> simpleType . listof__simpleType__    (rule 48)

	pipe           reduce using rule 47
	'('            shift, and enter state 22
	tname          shift, and enter state 49
	tvar           shift, and enter state 24
	sol            reduce using rule 47
	%eof           reduce using rule 47

	simpleType     goto state 78
	listof__simpleType__goto state 82

State 79

	ctor -> tname listof__simpleType__ .                (rule 38)

	pipe           reduce using rule 38
	sol            reduce using rule 38
	%eof           reduce using rule 38


State 80

	ctors -> ctor pipe . ctors                          (rule 41)

	tname          shift, and enter state 59

	ctor           goto state 57
	ctors          goto state 81

State 81

	ctors -> ctor pipe ctors .                          (rule 41)

	sol            reduce using rule 41
	%eof           reduce using rule 41


State 82

	listof__simpleType__ -> simpleType listof__simpleType__ .    (rule 48)

	pipe           reduce using rule 48
	sol            reduce using rule 48
	%eof           reduce using rule 48


State 83

	exp -> let var '=' exp in . exp                     (rule 8)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 86
	expapp         goto state 26
	atom           goto state 27

State 84

	exp -> if exp then exp else . exp                   (rule 9)

	let            shift, and enter state 28
	if             shift, and enter state 29
	int            shift, and enter state 30
	var            shift, and enter state 31
	op             shift, and enter state 32
	'('            shift, and enter state 33
	'λ'            shift, and enter state 34

	exp            goto state 85
	expapp         goto state 26
	atom           goto state 27

State 85

	exp -> if exp then exp else exp .                   (rule 9)

	in             reduce using rule 9
	then           reduce using rule 9
	else           reduce using rule 9
	')'            reduce using rule 9
	sol            reduce using rule 9
	%eof           reduce using rule 9


State 86

	exp -> let var '=' exp in exp .                     (rule 8)

	in             reduce using rule 8
	then           reduce using rule 8
	else           reduce using rule 8
	')'            reduce using rule 8
	sol            reduce using rule 8
	%eof           reduce using rule 8


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 51
Number of terminals: 21
Number of non-terminals: 20
Number of states: 87
