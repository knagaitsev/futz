-----------------------------------------------------------------------------
Info file generated by Happy Version 1.20.1.1 from src/Futz/Parser.y
-----------------------------------------------------------------------------


rule 4 is unused
rule 5 is unused
rule 6 is unused
rule 7 is unused
rule 8 is unused
rule 9 is unused
rule 10 is unused
rule 11 is unused
rule 12 is unused
rule 13 is unused
rule 14 is unused
rule 15 is unused
rule 16 is unused
rule 17 is unused
rule 18 is unused
rule 19 is unused
rule 20 is unused
rule 21 is unused
rule 22 is unused
rule 23 is unused
rule 24 is unused
rule 25 is unused
rule 29 is unused
rule 30 is unused
rule 31 is unused
rule 32 is unused
rule 33 is unused

terminal let is unused
terminal in is unused
terminal of is unused
terminal if is unused
terminal then is unused
terminal else is unused
terminal int is unused
terminal op is unused
terminal '=' is unused
terminal arr is unused
terminal 'λ' is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parseFutz -> toplevel                       (0)
	toplevel -> statement                              (1)
	toplevel -> statement toplevel                     (2)
	statement -> sol var "::" type                     (3)
	exp -> let var '=' exp in exp                      (4)
	exp -> if exp then exp else exp                    (5)
	exp -> 'λ' unmatching_args arr exp                 (6)
	exp -> var                                         (7)
	exp -> expapp                                      (8)
	exp -> atom of exp                                 (9)
	exp -> op op exp                                   (10)
	exp -> int                                         (11)
	exp -> op                                          (12)
	expapp -> expapp atom                              (13)
	expapp -> atom                                     (14)
	atom -> int                                        (15)
	atom -> var                                        (16)
	atom -> '(' op ')'                                 (17)
	atom -> '(' exp ')'                                (18)
	argument -> var                                    (19)
	args -> argument                                   (20)
	args -> argument args                              (21)
	unmatching_args -> var                             (22)
	unmatching_args -> var unmatching_args             (23)
	typeParameters -> type                             (24)
	typeParameters -> type typeParameters              (25)
	type -> tname                                      (26)
	type -> tvar                                       (27)
	type -> '(' type ')'                               (28)
	type0 -> type                                      (29)
	type0 -> tApp                                      (30)
	type0 -> type arr type                             (31)
	tApp -> type                                       (32)
	tApp -> tApp type                                  (33)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	let            { Tok _ LSyntax "let" }
	in             { Tok _ LSyntax "in" }
	of             { Tok _ LSyntax "of" }
	if             { Tok _ LSyntax "if" }
	then           { Tok _ LSyntax "then" }
	else           { Tok _ LSyntax "else" }
	int            { Tok _ LInt $$ }
	var            { Tok _ LSym $$ }
	op             { Tok _ LOp $$ }
	'='            { Tok _ LEq  _ }
	'('            { Tok _ LLParen _ }
	')'            { Tok _ LRParen _ }
	arr            { Tok _ LArrow _ }
	'λ'            { Tok _ LLambda _ }
	tname          { Tok _ LType $$ }
	tvar           { Tok _ LTypeVar $$ }
	"::"           { Tok _ LIsType _ }
	sol            { TStartOfLine }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parseFutz rule  0
	toplevel        rules 1, 2
	statement       rule  3
	exp             rules 4, 5, 6, 7, 8, 9, 10, 11, 12
	expapp          rules 13, 14
	atom            rules 15, 16, 17, 18
	argument        rule  19
	args            rules 20, 21
	unmatching_args rules 22, 23
	typeParameters  rules 24, 25
	type            rules 26, 27, 28
	type0           rules 29, 30, 31
	tApp            rules 32, 33

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0

	%start_parseFutz -> . toplevel                      (rule 0)

	sol            shift, and enter state 3

	toplevel       goto state 4
	statement      goto state 5

State 1

	toplevel -> . statement                             (rule 1)

	sol            shift, and enter state 3

	statement      goto state 2

State 2

	toplevel -> statement .                             (rule 1)



State 3

	statement -> sol . var "::" type                    (rule 3)

	var            shift, and enter state 7


State 4

	%start_parseFutz -> toplevel .                      (rule 0)

	%eof           accept


State 5

	toplevel -> statement .                             (rule 1)
	toplevel -> statement . toplevel                    (rule 2)

	sol            shift, and enter state 3
	%eof           reduce using rule 1

	toplevel       goto state 6
	statement      goto state 5

State 6

	toplevel -> statement toplevel .                    (rule 2)

	%eof           reduce using rule 2


State 7

	statement -> sol var . "::" type                    (rule 3)

	"::"           shift, and enter state 8


State 8

	statement -> sol var "::" . type                    (rule 3)

	'('            shift, and enter state 10
	tname          shift, and enter state 11
	tvar           shift, and enter state 12

	type           goto state 9

State 9

	statement -> sol var "::" type .                    (rule 3)

	sol            reduce using rule 3
	%eof           reduce using rule 3


State 10

	type -> '(' . type ')'                              (rule 28)

	'('            shift, and enter state 10
	tname          shift, and enter state 11
	tvar           shift, and enter state 12

	type           goto state 13

State 11

	type -> tname .                                     (rule 26)

	')'            reduce using rule 26
	sol            reduce using rule 26
	%eof           reduce using rule 26


State 12

	type -> tvar .                                      (rule 27)

	')'            reduce using rule 27
	sol            reduce using rule 27
	%eof           reduce using rule 27


State 13

	type -> '(' type . ')'                              (rule 28)

	')'            shift, and enter state 14


State 14

	type -> '(' type ')' .                              (rule 28)

	')'            reduce using rule 28
	sol            reduce using rule 28
	%eof           reduce using rule 28


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 34
Number of terminals: 18
Number of non-terminals: 13
Number of states: 15
