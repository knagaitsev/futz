-----------------------------------------------------------------------------
Info file generated by Happy Version 1.20.1.1 from src/Futz/Parser.y
-----------------------------------------------------------------------------

state 30 contains 7 reduce/reduce conflicts.
state 34 contains 7 reduce/reduce conflicts.
state 47 contains 1 shift/reduce conflicts.

rule 16 is unused
rule 20 is unused
rule 28 is unused
rule 29 is unused
rule 30 is unused
rule 41 is unused
rule 42 is unused
rule 43 is unused

terminal data is unused
terminal '=>' is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parseFutz -> top                            (0)
	top -> statement                                   (1)
	top -> statement top                               (2)
	statement -> sol def defnparts                     (3)
	defnparts -> defnpart                              (4)
	defnparts -> defnpart pipe defnparts               (5)
	defnpart -> var binding                            (6)
	defnpart -> '(' op ')' binding                     (7)
	defnpart -> var "::" qtype                         (8)
	defnpart -> '(' op ')' "::" qtype                  (9)
	binding -> listof__pattern__ '=' exp               (10)
	binding -> '=' exp                                 (11)
	pattern -> var                                     (12)
	exp -> let var '=' exp in exp                      (13)
	exp -> if exp then exp else exp                    (14)
	exp -> 'λ' args0 '->' exp                          (15)
	exp -> var                                         (16)
	exp -> expapp                                      (17)
	exp -> atom of exp                                 (18)
	exp -> atom op exp                                 (19)
	exp -> atom                                        (20)
	exp -> op                                          (21)
	expapp -> expapp atom                              (22)
	expapp -> atom                                     (23)
	atom -> int                                        (24)
	atom -> var                                        (25)
	atom -> '(' op ')'                                 (26)
	atom -> '(' exp ')'                                (27)
	argument -> var                                    (28)
	args -> argument                                   (29)
	args -> argument args                              (30)
	args0 -> var                                       (31)
	args0 -> var args0                                 (32)
	type -> btype '->' type                            (33)
	type -> btype                                      (34)
	btype -> btype atype                               (35)
	btype -> atype                                     (36)
	atype -> var                                       (37)
	atype -> tname                                     (38)
	atype -> '(' type ')'                              (39)
	qtype -> type                                      (40)
	preds -> pred                                      (41)
	preds -> pred pipe preds                           (42)
	pred -> tname atype                                (43)
	listof__pattern__ -> pattern                       (44)
	listof__pattern__ -> pattern listof__pattern__     (45)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	let            { Tok _ LSyntax "let" }
	in             { Tok _ LSyntax "in" }
	of             { Tok _ LSyntax "of" }
	if             { Tok _ LSyntax "if" }
	then           { Tok _ LSyntax "then" }
	else           { Tok _ LSyntax "else" }
	data           { Tok _ LSyntax "data" }
	def            { Tok _ LSyntax "def" }
	pipe           { Tok _ LPipe _ }
	'=>'           { Tok _ LOp "=>" }
	int            { Tok _ LInt _ }
	var            { Tok _ LSym _ }
	op             { Tok _ LOp _ }
	'='            { Tok _ LEq  _ }
	'('            { Tok _ LLParen _ }
	')'            { Tok _ LRParen _ }
	'->'           { Tok _ LArrow _ }
	'λ'            { Tok _ LLambda _ }
	tname          { Tok _ LType $$ }
	"::"           { Tok _ LIsType _ }
	sol            { TStartOfLine }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parseFutz rule  0
	top             rules 1, 2
	statement       rule  3
	defnparts       rules 4, 5
	defnpart        rules 6, 7, 8, 9
	binding         rules 10, 11
	pattern         rule  12
	exp             rules 13, 14, 15, 16, 17, 18, 19, 20, 21
	expapp          rules 22, 23
	atom            rules 24, 25, 26, 27
	argument        rule  28
	args            rules 29, 30
	args0           rules 31, 32
	type            rules 33, 34
	btype           rules 35, 36
	atype           rules 37, 38, 39
	qtype           rule  40
	preds           rules 41, 42
	pred            rule  43
	listof__pattern__ rules 44, 45

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0

	%start_parseFutz -> . top                           (rule 0)

	sol            shift, and enter state 3

	top            goto state 4
	statement      goto state 5

State 1

	top -> . statement                                  (rule 1)

	sol            shift, and enter state 3

	statement      goto state 2

State 2

	top -> statement .                                  (rule 1)



State 3

	statement -> sol . def defnparts                    (rule 3)

	def            shift, and enter state 7


State 4

	%start_parseFutz -> top .                           (rule 0)

	%eof           accept


State 5

	top -> statement .                                  (rule 1)
	top -> statement . top                              (rule 2)

	sol            shift, and enter state 3
	%eof           reduce using rule 1

	top            goto state 6
	statement      goto state 5

State 6

	top -> statement top .                              (rule 2)

	%eof           reduce using rule 2


State 7

	statement -> sol def . defnparts                    (rule 3)

	var            shift, and enter state 10
	'('            shift, and enter state 11

	defnparts      goto state 8
	defnpart       goto state 9

State 8

	statement -> sol def defnparts .                    (rule 3)

	sol            reduce using rule 3
	%eof           reduce using rule 3


State 9

	defnparts -> defnpart .                             (rule 4)
	defnparts -> defnpart . pipe defnparts              (rule 5)

	pipe           shift, and enter state 19
	sol            reduce using rule 4
	%eof           reduce using rule 4


State 10

	defnpart -> var . binding                           (rule 6)
	defnpart -> var . "::" qtype                        (rule 8)

	var            shift, and enter state 16
	'='            shift, and enter state 17
	"::"           shift, and enter state 18

	binding        goto state 13
	pattern        goto state 14
	listof__pattern__goto state 15

State 11

	defnpart -> '(' . op ')' binding                    (rule 7)
	defnpart -> '(' . op ')' "::" qtype                 (rule 9)

	op             shift, and enter state 12


State 12

	defnpart -> '(' op . ')' binding                    (rule 7)
	defnpart -> '(' op . ')' "::" qtype                 (rule 9)

	')'            shift, and enter state 40


State 13

	defnpart -> var binding .                           (rule 6)

	pipe           reduce using rule 6
	sol            reduce using rule 6
	%eof           reduce using rule 6


State 14

	listof__pattern__ -> pattern .                      (rule 44)
	listof__pattern__ -> pattern . listof__pattern__    (rule 45)

	var            shift, and enter state 16
	'='            reduce using rule 44

	pattern        goto state 14
	listof__pattern__goto state 39

State 15

	binding -> listof__pattern__ . '=' exp              (rule 10)

	'='            shift, and enter state 38


State 16

	pattern -> var .                                    (rule 12)

	var            reduce using rule 12
	'='            reduce using rule 12


State 17

	binding -> '=' . exp                                (rule 11)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 28
	expapp         goto state 29
	atom           goto state 30

State 18

	defnpart -> var "::" . qtype                        (rule 8)

	var            shift, and enter state 25
	'('            shift, and enter state 26
	tname          shift, and enter state 27

	type           goto state 21
	btype          goto state 22
	atype          goto state 23
	qtype          goto state 24

State 19

	defnparts -> defnpart pipe . defnparts              (rule 5)

	var            shift, and enter state 10
	'('            shift, and enter state 11

	defnparts      goto state 20
	defnpart       goto state 9

State 20

	defnparts -> defnpart pipe defnparts .              (rule 5)

	sol            reduce using rule 5
	%eof           reduce using rule 5


State 21

	qtype -> type .                                     (rule 40)

	pipe           reduce using rule 40
	sol            reduce using rule 40
	%eof           reduce using rule 40


State 22

	type -> btype . '->' type                           (rule 33)
	type -> btype .                                     (rule 34)
	btype -> btype . atype                              (rule 35)

	pipe           reduce using rule 34
	var            shift, and enter state 25
	'('            shift, and enter state 26
	')'            reduce using rule 34
	'->'           shift, and enter state 56
	tname          shift, and enter state 27
	sol            reduce using rule 34
	%eof           reduce using rule 34

	atype          goto state 55

State 23

	btype -> atype .                                    (rule 36)

	pipe           reduce using rule 36
	var            reduce using rule 36
	'('            reduce using rule 36
	')'            reduce using rule 36
	'->'           reduce using rule 36
	tname          reduce using rule 36
	sol            reduce using rule 36
	%eof           reduce using rule 36


State 24

	defnpart -> var "::" qtype .                        (rule 8)

	pipe           reduce using rule 8
	sol            reduce using rule 8
	%eof           reduce using rule 8


State 25

	atype -> var .                                      (rule 37)

	pipe           reduce using rule 37
	var            reduce using rule 37
	'('            reduce using rule 37
	')'            reduce using rule 37
	'->'           reduce using rule 37
	tname          reduce using rule 37
	sol            reduce using rule 37
	%eof           reduce using rule 37


State 26

	atype -> '(' . type ')'                             (rule 39)

	var            shift, and enter state 25
	'('            shift, and enter state 26
	tname          shift, and enter state 27

	type           goto state 54
	btype          goto state 22
	atype          goto state 23

State 27

	atype -> tname .                                    (rule 38)

	pipe           reduce using rule 38
	var            reduce using rule 38
	'('            reduce using rule 38
	')'            reduce using rule 38
	'->'           reduce using rule 38
	tname          reduce using rule 38
	sol            reduce using rule 38
	%eof           reduce using rule 38


State 28

	binding -> '=' exp .                                (rule 11)

	pipe           reduce using rule 11
	sol            reduce using rule 11
	%eof           reduce using rule 11


State 29

	exp -> expapp .                                     (rule 17)
	expapp -> expapp . atom                             (rule 22)

	in             reduce using rule 17
	then           reduce using rule 17
	else           reduce using rule 17
	pipe           reduce using rule 17
	int            shift, and enter state 33
	var            shift, and enter state 53
	'('            shift, and enter state 36
	')'            reduce using rule 17
	sol            reduce using rule 17
	%eof           reduce using rule 17

	atom           goto state 52

State 30

	exp -> atom . of exp                                (rule 18)
	exp -> atom . op exp                                (rule 19)
	exp -> atom .                                       (rule 20)
	expapp -> atom .                                    (rule 23)

	in             reduce using rule 23
			(reduce using rule 20)

	of             shift, and enter state 50
	then           reduce using rule 23
			(reduce using rule 20)

	else           reduce using rule 23
			(reduce using rule 20)

	pipe           reduce using rule 23
			(reduce using rule 20)

	int            reduce using rule 23
	var            reduce using rule 23
	op             shift, and enter state 51
	'('            reduce using rule 23
	')'            reduce using rule 23
			(reduce using rule 20)

	sol            reduce using rule 23
			(reduce using rule 20)

	%eof           reduce using rule 23
			(reduce using rule 20)



State 31

	exp -> let . var '=' exp in exp                     (rule 13)

	var            shift, and enter state 49


State 32

	exp -> if . exp then exp else exp                   (rule 14)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 48
	expapp         goto state 29
	atom           goto state 30

State 33

	atom -> int .                                       (rule 24)

	in             reduce using rule 24
	of             reduce using rule 24
	then           reduce using rule 24
	else           reduce using rule 24
	pipe           reduce using rule 24
	int            reduce using rule 24
	var            reduce using rule 24
	op             reduce using rule 24
	'('            reduce using rule 24
	')'            reduce using rule 24
	sol            reduce using rule 24
	%eof           reduce using rule 24


State 34

	exp -> var .                                        (rule 16)
	atom -> var .                                       (rule 25)

	in             reduce using rule 25
			(reduce using rule 16)

	of             reduce using rule 25
	then           reduce using rule 25
			(reduce using rule 16)

	else           reduce using rule 25
			(reduce using rule 16)

	pipe           reduce using rule 25
			(reduce using rule 16)

	int            reduce using rule 25
	var            reduce using rule 25
	op             reduce using rule 25
	'('            reduce using rule 25
	')'            reduce using rule 25
			(reduce using rule 16)

	sol            reduce using rule 25
			(reduce using rule 16)

	%eof           reduce using rule 25
			(reduce using rule 16)



State 35

	exp -> op .                                         (rule 21)

	in             reduce using rule 21
	then           reduce using rule 21
	else           reduce using rule 21
	pipe           reduce using rule 21
	')'            reduce using rule 21
	sol            reduce using rule 21
	%eof           reduce using rule 21


State 36

	atom -> '(' . op ')'                                (rule 26)
	atom -> '(' . exp ')'                               (rule 27)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 47
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 46
	expapp         goto state 29
	atom           goto state 30

State 37

	exp -> 'λ' . args0 '->' exp                         (rule 15)

	var            shift, and enter state 45

	args0          goto state 44

State 38

	binding -> listof__pattern__ '=' . exp              (rule 10)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 43
	expapp         goto state 29
	atom           goto state 30

State 39

	listof__pattern__ -> pattern listof__pattern__ .    (rule 45)

	'='            reduce using rule 45


State 40

	defnpart -> '(' op ')' . binding                    (rule 7)
	defnpart -> '(' op ')' . "::" qtype                 (rule 9)

	var            shift, and enter state 16
	'='            shift, and enter state 17
	"::"           shift, and enter state 42

	binding        goto state 41
	pattern        goto state 14
	listof__pattern__goto state 15

State 41

	defnpart -> '(' op ')' binding .                    (rule 7)

	pipe           reduce using rule 7
	sol            reduce using rule 7
	%eof           reduce using rule 7


State 42

	defnpart -> '(' op ')' "::" . qtype                 (rule 9)

	var            shift, and enter state 25
	'('            shift, and enter state 26
	tname          shift, and enter state 27

	type           goto state 21
	btype          goto state 22
	atype          goto state 23
	qtype          goto state 67

State 43

	binding -> listof__pattern__ '=' exp .              (rule 10)

	pipe           reduce using rule 10
	sol            reduce using rule 10
	%eof           reduce using rule 10


State 44

	exp -> 'λ' args0 . '->' exp                         (rule 15)

	'->'           shift, and enter state 66


State 45

	args0 -> var .                                      (rule 31)
	args0 -> var . args0                                (rule 32)

	var            shift, and enter state 45
	'->'           reduce using rule 31

	args0          goto state 65

State 46

	atom -> '(' exp . ')'                               (rule 27)

	')'            shift, and enter state 64


State 47

	exp -> op .                                         (rule 21)
	atom -> '(' op . ')'                                (rule 26)

	')'            shift, and enter state 63
			(reduce using rule 21)



State 48

	exp -> if exp . then exp else exp                   (rule 14)

	then           shift, and enter state 62


State 49

	exp -> let var . '=' exp in exp                     (rule 13)

	'='            shift, and enter state 61


State 50

	exp -> atom of . exp                                (rule 18)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 60
	expapp         goto state 29
	atom           goto state 30

State 51

	exp -> atom op . exp                                (rule 19)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 59
	expapp         goto state 29
	atom           goto state 30

State 52

	expapp -> expapp atom .                             (rule 22)

	in             reduce using rule 22
	then           reduce using rule 22
	else           reduce using rule 22
	pipe           reduce using rule 22
	int            reduce using rule 22
	var            reduce using rule 22
	'('            reduce using rule 22
	')'            reduce using rule 22
	sol            reduce using rule 22
	%eof           reduce using rule 22


State 53

	atom -> var .                                       (rule 25)

	in             reduce using rule 25
	then           reduce using rule 25
	else           reduce using rule 25
	pipe           reduce using rule 25
	int            reduce using rule 25
	var            reduce using rule 25
	'('            reduce using rule 25
	')'            reduce using rule 25
	sol            reduce using rule 25
	%eof           reduce using rule 25


State 54

	atype -> '(' type . ')'                             (rule 39)

	')'            shift, and enter state 58


State 55

	btype -> btype atype .                              (rule 35)

	pipe           reduce using rule 35
	var            reduce using rule 35
	'('            reduce using rule 35
	')'            reduce using rule 35
	'->'           reduce using rule 35
	tname          reduce using rule 35
	sol            reduce using rule 35
	%eof           reduce using rule 35


State 56

	type -> btype '->' . type                           (rule 33)

	var            shift, and enter state 25
	'('            shift, and enter state 26
	tname          shift, and enter state 27

	type           goto state 57
	btype          goto state 22
	atype          goto state 23

State 57

	type -> btype '->' type .                           (rule 33)

	pipe           reduce using rule 33
	')'            reduce using rule 33
	sol            reduce using rule 33
	%eof           reduce using rule 33


State 58

	atype -> '(' type ')' .                             (rule 39)

	pipe           reduce using rule 39
	var            reduce using rule 39
	'('            reduce using rule 39
	')'            reduce using rule 39
	'->'           reduce using rule 39
	tname          reduce using rule 39
	sol            reduce using rule 39
	%eof           reduce using rule 39


State 59

	exp -> atom op exp .                                (rule 19)

	in             reduce using rule 19
	then           reduce using rule 19
	else           reduce using rule 19
	pipe           reduce using rule 19
	')'            reduce using rule 19
	sol            reduce using rule 19
	%eof           reduce using rule 19


State 60

	exp -> atom of exp .                                (rule 18)

	in             reduce using rule 18
	then           reduce using rule 18
	else           reduce using rule 18
	pipe           reduce using rule 18
	')'            reduce using rule 18
	sol            reduce using rule 18
	%eof           reduce using rule 18


State 61

	exp -> let var '=' . exp in exp                     (rule 13)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 70
	expapp         goto state 29
	atom           goto state 30

State 62

	exp -> if exp then . exp else exp                   (rule 14)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 69
	expapp         goto state 29
	atom           goto state 30

State 63

	atom -> '(' op ')' .                                (rule 26)

	in             reduce using rule 26
	of             reduce using rule 26
	then           reduce using rule 26
	else           reduce using rule 26
	pipe           reduce using rule 26
	int            reduce using rule 26
	var            reduce using rule 26
	op             reduce using rule 26
	'('            reduce using rule 26
	')'            reduce using rule 26
	sol            reduce using rule 26
	%eof           reduce using rule 26


State 64

	atom -> '(' exp ')' .                               (rule 27)

	in             reduce using rule 27
	of             reduce using rule 27
	then           reduce using rule 27
	else           reduce using rule 27
	pipe           reduce using rule 27
	int            reduce using rule 27
	var            reduce using rule 27
	op             reduce using rule 27
	'('            reduce using rule 27
	')'            reduce using rule 27
	sol            reduce using rule 27
	%eof           reduce using rule 27


State 65

	args0 -> var args0 .                                (rule 32)

	'->'           reduce using rule 32


State 66

	exp -> 'λ' args0 '->' . exp                         (rule 15)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 68
	expapp         goto state 29
	atom           goto state 30

State 67

	defnpart -> '(' op ')' "::" qtype .                 (rule 9)

	pipe           reduce using rule 9
	sol            reduce using rule 9
	%eof           reduce using rule 9


State 68

	exp -> 'λ' args0 '->' exp .                         (rule 15)

	in             reduce using rule 15
	then           reduce using rule 15
	else           reduce using rule 15
	pipe           reduce using rule 15
	')'            reduce using rule 15
	sol            reduce using rule 15
	%eof           reduce using rule 15


State 69

	exp -> if exp then exp . else exp                   (rule 14)

	else           shift, and enter state 72


State 70

	exp -> let var '=' exp . in exp                     (rule 13)

	in             shift, and enter state 71


State 71

	exp -> let var '=' exp in . exp                     (rule 13)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 74
	expapp         goto state 29
	atom           goto state 30

State 72

	exp -> if exp then exp else . exp                   (rule 14)

	let            shift, and enter state 31
	if             shift, and enter state 32
	int            shift, and enter state 33
	var            shift, and enter state 34
	op             shift, and enter state 35
	'('            shift, and enter state 36
	'λ'            shift, and enter state 37

	exp            goto state 73
	expapp         goto state 29
	atom           goto state 30

State 73

	exp -> if exp then exp else exp .                   (rule 14)

	in             reduce using rule 14
	then           reduce using rule 14
	else           reduce using rule 14
	pipe           reduce using rule 14
	')'            reduce using rule 14
	sol            reduce using rule 14
	%eof           reduce using rule 14


State 74

	exp -> let var '=' exp in exp .                     (rule 13)

	in             reduce using rule 13
	then           reduce using rule 13
	else           reduce using rule 13
	pipe           reduce using rule 13
	')'            reduce using rule 13
	sol            reduce using rule 13
	%eof           reduce using rule 13


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 46
Number of terminals: 21
Number of non-terminals: 20
Number of states: 75
